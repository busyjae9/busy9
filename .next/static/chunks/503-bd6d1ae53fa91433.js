(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[503],{227:function(module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getDomainLocale=function(path,locale,locales,domainLocales){return!1},("function"==typeof exports.default||"object"==typeof exports.default&&null!==exports.default)&&void 0===exports.default.__esModule&&(Object.defineProperty(exports.default,"__esModule",{value:!0}),Object.assign(exports.default,exports),module.exports=exports.default)},1551:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _interop_require_default=__webpack_require__(2648).Z,_object_without_properties_loose=__webpack_require__(7273).Z,_react=_interop_require_default(__webpack_require__(7294)),_router=__webpack_require__(1003),_formatUrl=__webpack_require__(7795),_addLocale=__webpack_require__(4465),_routerContext=__webpack_require__(2692),_appRouterContext=__webpack_require__(8245),_useIntersection=__webpack_require__(9246),_getDomainLocale=__webpack_require__(227),_addBasePath=__webpack_require__(3468);let prefetched=new Set;function prefetch(router,href,as,options){if(_router.isLocalURL(href)){if(!options.bypassPrefetchedCheck){let locale=void 0!==options.locale?options.locale:"locale"in router?router.locale:void 0,prefetchedKey=href+"%"+as+"%"+locale;if(prefetched.has(prefetchedKey))return;prefetched.add(prefetchedKey)}Promise.resolve(router.prefetch(href,as,options)).catch(err=>{})}}function formatStringOrUrl(urlObjOrString){return"string"==typeof urlObjOrString?urlObjOrString:_formatUrl.formatUrl(urlObjOrString)}let Link=_react.default.forwardRef(function(props,forwardedRef){let children,child;let{href:hrefProp,as:asProp,children:childrenProp,prefetch:prefetchProp,passHref,replace,shallow,scroll,locale,onClick,onMouseEnter:onMouseEnterProp,onTouchStart:onTouchStartProp,legacyBehavior=!0!==Boolean(!0)}=props,restProps=_object_without_properties_loose(props,["href","as","children","prefetch","passHref","replace","shallow","scroll","locale","onClick","onMouseEnter","onTouchStart","legacyBehavior"]);children=childrenProp,legacyBehavior&&("string"==typeof children||"number"==typeof children)&&(children=_react.default.createElement("a",null,children));let prefetchEnabled=!1!==prefetchProp,pagesRouter=_react.default.useContext(_routerContext.RouterContext),appRouter=_react.default.useContext(_appRouterContext.AppRouterContext),router=null!=pagesRouter?pagesRouter:appRouter,isAppRouter=!pagesRouter,{href,as}=_react.default.useMemo(()=>{if(!pagesRouter){let resolvedHref=formatStringOrUrl(hrefProp);return{href:resolvedHref,as:asProp?formatStringOrUrl(asProp):resolvedHref}}let[resolvedHref1,resolvedAs]=_router.resolveHref(pagesRouter,hrefProp,!0);return{href:resolvedHref1,as:asProp?_router.resolveHref(pagesRouter,asProp):resolvedAs||resolvedHref1}},[pagesRouter,hrefProp,asProp]),previousHref=_react.default.useRef(href),previousAs=_react.default.useRef(as);legacyBehavior&&(child=_react.default.Children.only(children));let childRef=legacyBehavior?child&&"object"==typeof child&&child.ref:forwardedRef,[setIntersectionRef,isVisible,resetVisible]=_useIntersection.useIntersection({rootMargin:"200px"}),setRef=_react.default.useCallback(el=>{(previousAs.current!==as||previousHref.current!==href)&&(resetVisible(),previousAs.current=as,previousHref.current=href),setIntersectionRef(el),childRef&&("function"==typeof childRef?childRef(el):"object"==typeof childRef&&(childRef.current=el))},[as,childRef,href,resetVisible,setIntersectionRef]);_react.default.useEffect(()=>{router&&isVisible&&prefetchEnabled&&prefetch(router,href,as,{locale})},[as,href,isVisible,locale,prefetchEnabled,null==pagesRouter?void 0:pagesRouter.locale,router]);let childProps={ref:setRef,onClick(e){legacyBehavior||"function"!=typeof onClick||onClick(e),legacyBehavior&&child.props&&"function"==typeof child.props.onClick&&child.props.onClick(e),router&&!e.defaultPrevented&&function(e,router,href,as,replace,shallow,scroll,locale,isAppRouter,prefetchEnabled){let{nodeName}=e.currentTarget,isAnchorNodeName="A"===nodeName.toUpperCase();if(isAnchorNodeName&&(function(event){let{target}=event.currentTarget;return target&&"_self"!==target||event.metaKey||event.ctrlKey||event.shiftKey||event.altKey||event.nativeEvent&&2===event.nativeEvent.which}(e)||!_router.isLocalURL(href)))return;e.preventDefault();let navigate=()=>{"beforePopState"in router?router[replace?"replace":"push"](href,as,{shallow,locale,scroll}):router[replace?"replace":"push"](as||href,{forceOptimisticNavigation:!prefetchEnabled})};isAppRouter?_react.default.startTransition(navigate):navigate()}(e,router,href,as,replace,shallow,scroll,locale,isAppRouter,prefetchEnabled)},onMouseEnter(e){legacyBehavior||"function"!=typeof onMouseEnterProp||onMouseEnterProp(e),legacyBehavior&&child.props&&"function"==typeof child.props.onMouseEnter&&child.props.onMouseEnter(e),router&&(prefetchEnabled||!isAppRouter)&&prefetch(router,href,as,{locale,priority:!0,bypassPrefetchedCheck:!0})},onTouchStart(e){legacyBehavior||"function"!=typeof onTouchStartProp||onTouchStartProp(e),legacyBehavior&&child.props&&"function"==typeof child.props.onTouchStart&&child.props.onTouchStart(e),router&&(prefetchEnabled||!isAppRouter)&&prefetch(router,href,as,{locale,priority:!0,bypassPrefetchedCheck:!0})}};if(!legacyBehavior||passHref||"a"===child.type&&!("href"in child.props)){let curLocale=void 0!==locale?locale:null==pagesRouter?void 0:pagesRouter.locale,localeDomain=(null==pagesRouter?void 0:pagesRouter.isLocaleDomain)&&_getDomainLocale.getDomainLocale(as,curLocale,null==pagesRouter?void 0:pagesRouter.locales,null==pagesRouter?void 0:pagesRouter.domainLocales);childProps.href=localeDomain||_addBasePath.addBasePath(_addLocale.addLocale(as,curLocale,null==pagesRouter?void 0:pagesRouter.defaultLocale))}return legacyBehavior?_react.default.cloneElement(child,childProps):_react.default.createElement("a",Object.assign({},restProps,childProps),children)});exports.default=Link,("function"==typeof exports.default||"object"==typeof exports.default&&null!==exports.default)&&void 0===exports.default.__esModule&&(Object.defineProperty(exports.default,"__esModule",{value:!0}),Object.assign(exports.default,exports),module.exports=exports.default)},9246:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.useIntersection=function(param){let{rootRef,rootMargin,disabled}=param,isDisabled=disabled||!hasIntersectionObserver,[visible,setVisible]=_react.useState(!1),[element,setElement]=_react.useState(null);_react.useEffect(()=>{if(hasIntersectionObserver){if(!isDisabled&&!visible&&element&&element.tagName){let unobserve=function(element,callback,options){let{id,observer,elements}=function(options){let instance;let id={root:options.root||null,margin:options.rootMargin||""},existing=idList.find(obj=>obj.root===id.root&&obj.margin===id.margin);if(existing&&(instance=observers.get(existing)))return instance;let elements=new Map,observer=new IntersectionObserver(entries=>{entries.forEach(entry=>{let callback=elements.get(entry.target),isVisible=entry.isIntersecting||entry.intersectionRatio>0;callback&&isVisible&&callback(isVisible)})},options);return instance={id,observer,elements},idList.push(id),observers.set(id,instance),instance}(options);return elements.set(element,callback),observer.observe(element),function(){if(elements.delete(element),observer.unobserve(element),0===elements.size){observer.disconnect(),observers.delete(id);let index=idList.findIndex(obj=>obj.root===id.root&&obj.margin===id.margin);index>-1&&idList.splice(index,1)}}}(element,isVisible=>isVisible&&setVisible(isVisible),{root:null==rootRef?void 0:rootRef.current,rootMargin});return unobserve}}else if(!visible){let idleCallback=_requestIdleCallback.requestIdleCallback(()=>setVisible(!0));return()=>_requestIdleCallback.cancelIdleCallback(idleCallback)}},[element,isDisabled,rootMargin,rootRef,visible]);let resetVisible=_react.useCallback(()=>{setVisible(!1)},[]);return[setElement,visible,resetVisible]};var _react=__webpack_require__(7294),_requestIdleCallback=__webpack_require__(4686);let hasIntersectionObserver="function"==typeof IntersectionObserver,observers=new Map,idList=[];("function"==typeof exports.default||"object"==typeof exports.default&&null!==exports.default)&&void 0===exports.default.__esModule&&(Object.defineProperty(exports.default,"__esModule",{value:!0}),Object.assign(exports.default,exports),module.exports=exports.default)},1664:function(module,__unused_webpack_exports,__webpack_require__){module.exports=__webpack_require__(1551)},1163:function(module,__unused_webpack_exports,__webpack_require__){module.exports=__webpack_require__(880)},8074:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";function utils_isIterable(a){return"function"==typeof(null==a?void 0:a[Symbol.iterator])}function utils_isAsyncIterable(a){return"function"==typeof(null==a?void 0:a[Symbol.asyncIterator])}__webpack_require__.d(__webpack_exports__,{oA:function(){return Lazy_compact},$H:function(){return Lazy_flat},UI:function(){return Lazy_map},zG:function(){return esm_pipe},u4:function(){return esm_reduce},VO:function(){return Lazy_values}});let empty=function*(){},isNotNullable=a=>null!=a,utils_isPromise=a=>a instanceof Promise||null!==a&&"object"==typeof a&&"function"==typeof a.then&&"function"==typeof a.catch;class error_AsyncFunctionException extends Error{constructor(message=error_AsyncFunctionException.MESSAGE){super(message)}}error_AsyncFunctionException.MESSAGE=`'Iterable' can not used with async function.
If you want to deal with async function, see: [toAsync](https://fxts.dev/docs/toAsync)`;var Lazy_map=function map_map(f,iterable){if(void 0===iterable)return iterable=>map_map(f,iterable);if(utils_isIterable(iterable))return function(f,iterable){let iterator=iterable[Symbol.iterator]();return{next(){let{done,value}=iterator.next();if(done)return{done:!0,value:void 0};let res=f(value);if(utils_isPromise(res))throw new error_AsyncFunctionException;return{done:!1,value:res}},[Symbol.iterator](){return this}}}(f,iterable);if(utils_isAsyncIterable(iterable))return function(f,iterable){let iterator=iterable[Symbol.asyncIterator]();return{async next(_concurrent){let{done,value}=await iterator.next(_concurrent);return done?{done,value}:{done:!1,value:await f(value)}},[Symbol.asyncIterator](){return this}}}(f,iterable);throw TypeError("'iterable' must be type of Iterable or AsyncIterable")};class Concurrent{constructor(length){this.length=length}static of(length){return new Concurrent(length)}}let concurrent_isConcurrent=concurrent=>concurrent instanceof Concurrent;var Lazy_concurrent=function concurrent_concurrent(length,iterable){if(void 0===iterable)return iterable=>concurrent_concurrent(length,iterable);if(length===1/0)throw RangeError("'length' cannot be infinite");if(length<=0)throw RangeError("'length' must be over 0");if(!utils_isAsyncIterable(iterable))throw TypeError("'iterable' must be type of AsyncIterable");let iterator=iterable[Symbol.asyncIterator](),buffer=[],prev=Promise.resolve(),nextCallCount=0,resolvedItemCount=0,finished=!1,pending=!1,settlementQueue=[],consumeBuffer=()=>{for(;buffer.length>0&&nextCallCount>resolvedItemCount;){let p=buffer.shift(),[resolve,reject]=settlementQueue.shift();if("fulfilled"===p.status)resolvedItemCount++,resolve(p.value),p.value.done&&(finished=!0);else{reject(p.reason),finished=!0;break}}},fillBuffer=()=>{if(pending)prev=prev.then(()=>void(!finished&&nextCallCount>resolvedItemCount&&fillBuffer()));else{let nextItems=Promise.allSettled(Array.from({length},()=>iterator.next(Concurrent.of(length))));pending=!0,prev=prev.then(()=>nextItems).then(nextItems=>{buffer.push(...nextItems),pending=!1,recur()})}};function recur(){finished||nextCallCount===resolvedItemCount||(buffer.length>0?consumeBuffer():fillBuffer())}return{[Symbol.asyncIterator](){return this},next:()=>(nextCallCount++,finished)?{done:!0,value:void 0}:new Promise((resolve,reject)=>{settlementQueue.push([resolve,reject]),recur()})}};let pipe1_pipe1=(a,f)=>utils_isPromise(a)?a.then(f):f(a);async function*filter_asyncSequential(f,iterable){for await(let item of iterable)await f(item)&&(yield item)}var Lazy_filter=function filter_filter(f,iterable){if(void 0===iterable)return iterable=>filter_filter(f,iterable);if(utils_isIterable(iterable))return function*(f,iterable){for(let a of iterable){let res=f(a);if(utils_isPromise(res))throw new error_AsyncFunctionException;res&&(yield a)}}(f,iterable);if(utils_isAsyncIterable(iterable)){let _iterator;return{next:async _concurrent=>(void 0===_iterator&&(_iterator=concurrent_isConcurrent(_concurrent)?function(iterable){let iterator=iterable[Symbol.asyncIterator](),settlementQueue=[],buffer=[],finished=!1,nextCallCount=0,resolvedCount=0,prevItem=Promise.resolve();return{next:async concurrent=>(nextCallCount++,finished)?{done:!0,value:void 0}:new Promise((resolve,reject)=>{settlementQueue.push([resolve,reject]),function recur(concurrent){finished||nextCallCount===resolvedCount||(buffer.length>0?function(){for(;buffer.length>0&&nextCallCount>resolvedCount;){let value=buffer.shift(),[resolve]=settlementQueue.shift();resolve({done:!1,value}),resolvedCount++}}():function(concurrent){let nextItem=iterator.next(concurrent);prevItem=prevItem.then(()=>nextItem).then(({done,value})=>{if(done){for(;settlementQueue.length>0;){let[resolve]=settlementQueue.shift();resolve({done:!0,value:void 0})}return void(finished=!0)}let[cond,item]=value;cond&&buffer.push(item),recur(concurrent)}).catch(reason=>{for(finished=!0;settlementQueue.length>0;){let[,reject]=settlementQueue.shift();reject(reason)}})}(concurrent))}(concurrent)}),[Symbol.asyncIterator](){return this}}}(Lazy_concurrent(_concurrent.length,function(f,iterable){let iterator=iterable[Symbol.asyncIterator]();return{[Symbol.asyncIterator](){return this},async next(_concurrent){let{done,value}=await iterator.next(_concurrent);return done?{done:!0,value:void 0}:pipe1_pipe1(f(value),cond=>({done,value:[Boolean(cond),value]}))}}}(f,iterable))):filter_asyncSequential(f,iterable)),_iterator.next(_concurrent)),[Symbol.asyncIterator](){return this}}}throw TypeError("'iterable' must be type of Iterable or AsyncIterable")};function reduce_sync(f,acc,iterable){for(let a of iterable)acc=f(acc,a);return acc}async function reduce_async(f,acc,iterable){for await(let a of iterable)acc=await pipe1_pipe1(acc,acc=>f(acc,a));return acc}var esm_reduce=function reduce_reduce(f,seed,iterable){if(void 0===iterable){if(void 0===seed)return iterable=>reduce_reduce(f,iterable);if(utils_isIterable(seed)){let iterator=seed[Symbol.iterator](),{done,value}=iterator.next();if(done)return;return reduce_sync(f,value,{[Symbol.iterator]:()=>iterator})}if(utils_isAsyncIterable(seed)){let iterator1=seed[Symbol.asyncIterator]();return iterator1.next().then(({done,value})=>{if(!done)return reduce_async(f,value,{[Symbol.asyncIterator]:()=>iterator1})})}throw TypeError("'iterable' must be type of Iterable or AsyncIterable")}if(utils_isIterable(iterable))return reduce_sync(f,seed,iterable);if(utils_isAsyncIterable(iterable))return reduce_async(f,Promise.resolve(seed),iterable);throw TypeError("'iterable' must be type of Iterable or AsyncIterable")},esm_pipe=function(a,...fns){return esm_reduce(pipe1_pipe1,a,fns)};let rsAstralRange="\ud800-\udfff",rsAstral=`[${rsAstralRange}]`,rsCombo=`[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\u1ab0-\\u1aff\\u1dc0-\\u1dff]`,rsFitz="\ud83c[\udffb-\udfff]",rsModifier=`(?:${rsCombo}|${rsFitz})`,rsNonAstral=`[^${rsAstralRange}]`,rsRegional="(?:\ud83c[\udde6-\uddff]){2}",rsSurrPair="[\ud800-\udbff][\udc00-\udfff]",reOptMod=`${rsModifier}?`,rsOptVar=`[\\ufe0e\\ufe0f]?`,rsOptJoin=`(?:\\u200d(?:${[rsNonAstral,rsRegional,rsSurrPair].join("|")})${rsOptVar+reOptMod})*`,rsNonAstralCombo=`${rsNonAstral}${rsCombo}?`,rsSymbol=`(?:${[rsNonAstralCombo,rsCombo,rsRegional,rsSurrPair,rsAstral].join("|")})`;RegExp(`${rsFitz}(?=${rsFitz})|${rsSymbol+(rsOptVar+reOptMod+rsOptJoin)}`,"g");var Lazy_compact=function(iterable){if(utils_isIterable(iterable)||utils_isAsyncIterable(iterable))return Lazy_filter(isNotNullable,iterable);throw TypeError("'iterable' must be type of Iterable or AsyncIterable")},esm_last=function(iterable){if(Array.isArray(iterable)||"string"==typeof iterable)return iterable[iterable.length-1];if(utils_isIterable(iterable))return esm_reduce((_,a)=>a,iterable);if(utils_isAsyncIterable(iterable))return esm_reduce((_,a)=>a,iterable);throw TypeError("'iterable' must be type of Iterable or AsyncIterable")};function append_asyncSequential(a,iterable){let iterator=iterable[Symbol.asyncIterator](),finished=!1;return{[Symbol.asyncIterator](){return this},async next(){if(finished)return{done:!0,value:void 0};let{value,done}=await iterator.next();return finished?{done:!0,value:void 0}:done?(finished=!0,{done:!1,value:await a}):{done,value}}}}var Lazy_append=function append(a,iterable){if(void 0===iterable)return iterable=>append(a,iterable);if(utils_isAsyncIterable(iterable)){var a1;let iterator;return a1=utils_isPromise(a)?a:Promise.resolve(a),iterator=null,{[Symbol.asyncIterator](){return this},next:async _concurrent=>(null===iterator&&(iterator=concurrent_isConcurrent(_concurrent)?append_asyncSequential(a1,Lazy_concurrent(_concurrent.length,iterable)):append_asyncSequential(a1,iterable)),iterator.next(_concurrent))}}if(utils_isIterable(iterable))return function*(a,iterable){yield*iterable,yield a}(a,iterable);throw TypeError("'iterable' must be type of Iterable or AsyncIterable")};function toAsyncIterable(iterable){if(utils_isAsyncIterable(iterable))return iterable;let iterator=iterable[Symbol.iterator]();return{[Symbol.asyncIterator]:()=>iterator}}var Lazy_concat=function concat(iterable1,iterable2){if(void 0===iterable2)return iterable2=>concat(iterable1,iterable2);if(utils_isAsyncIterable(iterable1)||utils_isAsyncIterable(iterable2))return function(a,b){let leftDone=!1,leftIterator=a[Symbol.asyncIterator](),rightIterator=b[Symbol.asyncIterator]();return{[Symbol.asyncIterator](){return this},async next(_concurrent){let iterator=leftDone?rightIterator:leftIterator,{done,value}=await iterator.next(_concurrent);return done?(iterator===leftIterator&&(leftDone=!0),rightIterator.next(_concurrent)):{done,value}}}}(toAsyncIterable(iterable1),toAsyncIterable(iterable2));if(utils_isIterable(iterable1)&&utils_isIterable(iterable2))return function*(a,b){yield*a,yield*b}(iterable1,iterable2);throw TypeError("'iterable1','iterable2' must be type of Iterable or AsyncIterable")};let isFlatAble=function(a){return"string"!=typeof a&&utils_isIterable(a)};function flat_sync(iterable,depth){let iterator=iterable[Symbol.iterator](),iteratorStack=[iterator];return{[Symbol.iterator](){return this},next(){let iterator=esm_last(iteratorStack);if(!iterator)return{done:!0,value:void 0};let{value,done}=iterator.next();return done?(iteratorStack.pop(),this.next()):isFlatAble(value)&&iteratorStack.length<depth+1?(iteratorStack.push(value[Symbol.iterator]()),this.next()):{done:!1,value}}}}var Lazy_flat=function(iterable,depth=1){if(utils_isIterable(iterable))return flat_sync(iterable,depth);if(utils_isAsyncIterable(iterable)){let _iterator;return _iterator=null,{next:async _concurrent=>(null===_iterator&&(_iterator=concurrent_isConcurrent(_concurrent)?function(iterable,depth){let originIterator=iterable[Symbol.asyncIterator](),prevItem=Promise.resolve(),flattenIterator=empty(),finished=!1,settlementQueue=[],fillItem=async()=>{let{done,value}=await originIterator.next();return!done&&(flattenIterator=isFlatAble(value)?Lazy_concat(flat_sync(value,depth-1),flattenIterator):Lazy_append(value,flattenIterator),!0)},pullItem=async()=>{if(finished)return{done:!0,value:void 0};let{value,done}=flattenIterator.next();if(done){let hasItem=await fillItem();return hasItem?pullItem():{done:!0,value:void 0}}return{done:!1,value}},resolveItem=({done,value})=>{if(done||finished){for(;settlementQueue.length>0;){let[resolve]=settlementQueue.shift();resolve({done:!0,value:void 0})}return}let[resolve1]=settlementQueue.shift();resolve1({done,value})},catchItem=err=>{finished=!0;let[_,reject]=settlementQueue.shift();reject(err)};return{[Symbol.asyncIterator](){return this},next:async()=>new Promise((resolve,reject)=>{settlementQueue.push([resolve,reject]),prevItem=prevItem.then(()=>pullItem()).then(resolveItem).catch(catchItem)})}}(Lazy_concurrent(_concurrent.length,iterable),depth):function(iterable,depth){let iterator=iterable[Symbol.asyncIterator](),iteratorStack=[iterator];return{[Symbol.asyncIterator](){return this},async next(){let iterator=esm_last(iteratorStack);if(!iterator)return{done:!0,value:void 0};let{value,done}=await iterator.next();return done?(iteratorStack.pop(),this.next()):isFlatAble(value)&&iteratorStack.length<depth+1?(iteratorStack.push(value[Symbol.iterator]()),this.next()):{done:!1,value}}}}(iterable,depth)),_iterator.next(_concurrent)),[Symbol.asyncIterator](){return this}}}throw TypeError("'iterable' must be type of Iterable or AsyncIterable")},Lazy_values=function*(obj){for(let k in obj)Object.prototype.hasOwnProperty.call(obj,k)&&(yield obj[k])}}}]);